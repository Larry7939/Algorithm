#수열의 반복을 이용하여, 가장 큰 수와 두번째로 큰 수의 등장 횟수의 공식을 도출하여
#더 큰 데이터가 입력되더라도 time-out이 발생하지 않도록 함.
#간단하게 푸는 방법 -> 배열을 정렬해놓고 큰 수를 K번, 작은 수를 1번씩 더해주면 된다.
#최적의 해 방법 -> 수열이 반복되는 것을 이용해서 큰 수와 작은 수가 각각 몇번 더해지는 지 공식을 구하고 곱해주기만 하면 된다.

N,M,K = list(map(int,input().split()))
a = list(map(int,input().split()))

#큰수가 더해지는 횟수 공식-> K가 3이면 수열이 2번 반복된다.
#수열의 반복횟수 -> M//K+1
#큰 수가 더해지는 횟수 -> K * (M//K+1)
#작은 수가 더해지는 횟수 -> 

# M이 짝수라서 나눠떨어지는 경우. EX) 2 2 2 1 2 2 2 1
# 수열의 길이 -> K+1
# 수열이 등장하는 횟수 -> M//K+1
# 큰 수가 더해지는 횟수 -> M//(K+1) * K
# 작은 수가 더해지는 횟수 -> M//K+1

# M이 홀수라서 나눠떨어지지 않는 경우 포 함. EX) 2 2 2 1 2 2 2
# M//(K+1) * K + M%(K+1) 
# 작은 수가 등장하는 횟수 -> M//K+1
result = 0
a.sort()
first = a[N-1]
second = a[N-2]

#만약에 수열이 깔끔하게 반복된다면, 두번째 항(나머지 큰 수 덧셈)은 0이 될 것이다.
result = (M//(K+1)*K)*first + M%(K+1)*first + M//(K+1)*second

print(result)
